/*( getnum int2173 )*/

#pragma option -1

#define DEMO

long getnum();
unsigned long start;
int ld,d,lk;
unsigned int secsize,secshft,dirsec,dircnt,maxsec;
int h8=255;
int s8=63;
int mt=0;
int l40=0;

#ifndef DEMO

unsigned char fat16[]={
0xeb,0x3c,0x90,0x52,0x2e,0x20,0x4c,0x6f,0x65,0x77,0x20,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x29,0,0,0,0,0x4e,0x4f,0x20,0x4e,0x41,
0x4d,0x45,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0 ,0x20,0x20,0x20,0x33,0xc9,
0x8e,0xd1,0xbc,0xfc,0x7b,0x16,7,0xbd,0x78,0,0xc5,0x76,0,0x1e,0x56,0x16,
0x55,0xbf,0x22,5,0x89,0x7e,0,0x89,0x4e,2,0xb1,0xb,0xfc,0xf3,0xa4,6,
0x1f,0xbd,0,0x7c,0xc6,0x45,0xfe,0xf,0x38,0x4e,0x24,0x7d,0x20,0x8b,0xc1,0x99,
0xe8,0x7e,1,0xbb,0xc6,8,0x66,0xa1,0x1c,0x7c,0x66,0x3b,7,0x8a,0x57,0xfc,
0x75,6,0x80,0xca,2,0x88,0x56,2,0x80,0xc3,0x10,0x73,0xed,0x33,0xc9,0xfe,
6,0xd8,0x7d,0x8a,0x46,0x10,0x98,0xf7,0x66,0x16,3,0x46,0x1c,0x13,0x56,0x1e,
3,0x46,0xe,0x13,0xd1,0x8b,0x76,0x11,0x60,0x89,0x46,0xfc,0x89,0x56,0xfe,0xb8,
0x20,0,0xf7,0xe6,0x8b,0x5e,0xb,3,0xc3,0x48,0xf7,0xf3,1,0x46,0xfc,0x11,
0x4e,0xfe,0x61,0xbf,0,7,0xe8,0x28,1,0x72,0x3e,0x38,0x2d,0x74,0x17,0x60,
0xb1,0xb,0xbe,0xd8,0x7d,0xf3,0xa6,0x61,0x74,0x3d,0x4e,0x74,9,0x83,0xc7,0x20,
0x3b,0xfb,0x72,0xe7,0xeb,0xdd,0xfe,0xe,0xd8,0x7d,0x7b,0xa7,0xbe,0x7f,0x7d,0xac,
0x98,3,0xf0,0xac,0x98,0x40,0x74,0xc,0x48,0x74,0x13,0xb4,0xe,0xbb,7,0,
0xcd,0x10,0xeb,0xef,0xbe,0x82,0x7d,0xeb,0xe6,0xbe,0x80,0x7d,0xeb,0xe1,0xcd,0x16,
0x5e,0x1f,0x66,0x8f,4,0xcd,0x19,0xbe,0x81,0x7d,0x8b,0x7d,0x1a,0x8d,0x45,0xfe,
0x8a,0x4e,0xd,0xf7,0xe1,3,0x46,0xfc,0x13,0x56,0xfe,0xb1,4,0xe8,0xc2,0,
0x72,0xd7,0xea,0,2,0x70,0,0x52,0x50,6,0x53,0x6a,1,0x6a,0x10,0x91,
0x8b,0x46,0x18,0xa2,0x26,5,0x96,0x92,0x33,0xd2,0xf7,0xf6,0x91,0xf7,0xf6,0x42,
0x87,0xca,0xf7,0x76,0x1a,0x8a,0xf2,0x8a,0xe8,0xc0,0xcc,2,0xa,0xcc,0xb8,1,
2,0x80,0x7e,2,0xe,0x75,4,0xb4,0x42,0x8b,0xf4,0x8a,0x56,0x24,0xcd,0x13,
0x61,0x61,0x72,0xa,0x40,0x75,1,0x42,3,0x5e,0xb,0x49,0x75,0x77,0xc3,3,
0x18,1,0x27,0xd,0xa,0x49,0x6e,0x76,0x61,0x6c,0x69,0x64,0x20,0x73,0x79,0x73,
0x74,0x65,0x6d,0x20,0x64,0x69,0x73,0x6b,0xff,0xd,0xa,0x44,0x69,0x73,0x6b,0x20,
0x49,0x2f,0x4f,0x20,0x65,0x72,0x72,0x6f,0x72,0xff,0xd,0xa,0x52,0x65,0x70,0x6c,
0x61,0x63,0x65,0x20,0x74,0x68,0x65,0x20,0x64,0x69,0x73,0x6b,0x2c,0x20,0x74,0x68,
0x65,0x6e,0x20,0x70,0x72,0x65,0x73,0x73,0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,
0xd,0xa,0,0x52,0x52,0x4c,0,0,0x49,0x4f,0x20,0x20,0x20,0x20,0x20,0x20,
0x53,0x59,0x53,0x4d,0x53,0x44,0x4f,0x53,0x20,0x20,0x20,0x53,0x59,0x53,0x7f,0x7d,
0,0x41,0xbb,0,7,0x60,0x66,0x6a,0,0xe9,0x3b,0xff,0,0,0x55,0xaa
};

unsigned char fat16b[]={
0xeb,0x3c,0x90,0x52,0x2e,0x20,0x4c,0x6f,0x65,0x77,0x20,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x29,0,0,0,0,0x4e,0x4f,0x20,0x4e,0x41,
0x4d,0x45,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0 ,0x20,0x20,0x20,0x33,0xc9,
0x8e,0xd1,0xbc,0xfc,0x7b,0x16,7,0xbd,0x78,0,0xc5,0x76,0,0x1e,0x56,0x16,
0x55,0xbf,0x22,5,0x89,0x7e,0,0x89,0x4e,2,0xb1,0xb,0xfc,0xf3,0xa4,6,
0x1f,0xbd,0,0x7c,0xc6,0x45,0xfe,0xf,0x38,0x4e,0x24,0x7d,0x20,0x8b,0xc1,0x99,
0xe8,0x7e,1,0xbb,0xc6,0x7f,0x66,0xa1,0x1c,0x7c,0x66,0x3b,7,0x8a,0x57,0xfc,
0x75,6,0x80,0xca,2,0x88,0x56,2,0x80,0xc3,0x10,0x73,0xed,0x33,0xc9,0xfe,
6,0xd8,0x7d,0x8a,0x46,0x10,0x98,0xf7,0x66,0x16,3,0x46,0x1c,0x13,0x56,0x1e,
3,0x46,0xe,0x13,0xd1,0x8b,0x76,0x11,0x60,0x89,0x46,0xfc,0x89,0x56,0xfe,0xb8,
0x20,0,0xf7,0xe6,0x8b,0x5e,0xb,3,0xc3,0x48,0xf7,0xf3,1,0x46,0xfc,0x11,
0x4e,0xfe,0x61,0xbf,0,0x7e,0xe8,0x28,1,0x72,0x3e,0x38,0x2d,0x74,0x17,0x60,
0xb1,0xb,0xbe,0xd8,0x7d,0xf3,0xa6,0x61,0x74,0x3d,0x4e,0x74,9,0x83,0xc7,0x20,
0x3b,0xfb,0x72,0xe7,0xeb,0xdd,0xfe,0xe,0xd8,0x7d,0x7b,0xa7,0xbe,0x7f,0x7d,0xac,
0x98,3,0xf0,0xac,0x98,0x40,0x74,0xc,0x48,0x74,0x13,0xb4,0xe,0xbb,7,0,
0xcd,0x10,0xeb,0xef,0xbe,0x82,0x7d,0xeb,0xe6,0xbe,0x80,0x7d,0xeb,0xe1,0xcd,0x16,
0x5e,0x1f,0x66,0x8f,4,0xcd,0x19,0xbe,0x81,0x7d,0x8b,0x7d,0x1a,0x8d,0x45,0xfe,
0x8a,0x4e,0xd,0xf7,0xe1,3,0x46,0xfc,0x13,0x56,0xfe,0xb1,1,0xe8,0xc2,0,
0x72,0xd7,0xea,0,2,0xe0,7,0x52,0x50,6,0x53,0x6a,1,0x6a,0x10,0x91,
0x8b,0x46,0x18,0xa2,0x26,5,0x96,0x92,0x33,0xd2,0xf7,0xf6,0x91,0xf7,0xf6,0x42,
0x87,0xca,0xf7,0x76,0x1a,0x8a,0xf2,0x8a,0xe8,0xc0,0xcc,2,0xa,0xcc,0xb8,1,
2,0x80,0x7e,2,0xe,0x75,4,0xb4,0x42,0x8b,0xf4,0x8a,0x56,0x24,0xcd,0x13,
0x61,0x61,0x72,0xa,0x40,0x75,1,0x42,3,0x5e,0xb,0x49,0x75,0x77,0xc3,3,
0x18,1,0x27,0xd,0xa,0x49,0x6e,0x76,0x61,0x6c,0x69,0x64,0x20,0x73,0x79,0x73,
0x74,0x65,0x6d,0x20,0x64,0x69,0x73,0x6b,0xff,0xd,0xa,0x44,0x69,0x73,0x6b,0x20,
0x49,0x2f,0x4f,0x20,0x65,0x72,0x72,0x6f,0x72,0xff,0xd,0xa,0x52,0x65,0x70,0x6c,
0x61,0x63,0x65,0x20,0x74,0x68,0x65,0x20,0x64,0x69,0x73,0x6b,0x2c,0x20,0x74,0x68,
0x65,0x6e,0x20,0x70,0x72,0x65,0x73,0x73,0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,
0xd,0xa,0,0x52,0x52,0x4c,0,0,0x49,0x4f,0x20,0x20,0x20,0x20,0x20,0x20,
0x53,0x59,0x53,0x4d,0x53,0x44,0x4f,0x53,0x20,0x20,0x20,0x53,0x59,0x53,0x7f,0x7d,
0,0x41,0xbb,0,0x7e,0x60,0x66,0x6a,0,0xe9,0x3b,0xff,0,0,0x55,0xaa
};

unsigned char fat32[]={
0xeb,0x58,0x90,0x52,0x2e,0x20,0x4c,0x6f,0x65,0x77,0x20,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x29,0,0,0,0,0x4e,0x4f,0x20,0x4e,0x41,0x4d,0x45,0x20,0x20,
0x20,0x20,0x46,0x41,0x54,0x33,0x32,0x20,0x20,0x20,0xfa,0x33,0xc9,0x8e,0xd1,0xbc,
0xf8,0x7b,0x8e,0xc1,0xbd,0x78,0,0xc5,0x76,0,0x1e,0x56,0x16,0x55,0xbf,0x22,
5,0x89,0x7e,0,0x89,0x4e,2,0xb1,0xb,0xfc,0xf3,0xa4,0x8e,0xd9,0xbd,0,
0x7c,0xc6,0x45,0xfe,0xf,0x8b,0x46,0x18,0x88,0x45,0xf9,0x38,0x4e,0x40,0x7d,0x25,
0x8b,0xc1,0x99,0xbb,0,0x80,0xe8,0x97,0,0x72,0x1a,0xbb,0xc6,0x81,0x66,0xa1,
0x1c,0x7c,0x66,0x3b,7,0x8a,0x57,0xfc,0x75,6,0x80,0xca,2,0x88,0x56,2,
0x80,0xc3,0x10,0x73,0xed,0xbf,2,0,0x83,0x7e,0x16,0,0x75,0x45,0x8b,0x46,
0x1c,0x8b,0x56,0x1e,0x90,0xb9,1,0,5,2,0,0x75,1,0x42,0xbb,0,0x80,0xe8,
0x5d,0,0x73,0x24,0x4f,0x74,0x1d,0x8b,0x46,0x32,0x33,0xd2,0xb9,3,
0,0x3b,0xc8,0x77,0x1e,0x8b,0x76,0xe,0x3b,0xce,0x73,0x17,0x2b,0xf1,3,0x46,
0x1c,0x13,0x56,0x1e,0xeb,0xcf,0x73,0xb,0xeb,0x27,0x83,0x7e,0x2a,0,0x77,3,
0xe9,0xfd,2,0xbe,0x7e,0x7d,0xac,0x98,3,0xf0,0xac,0x84,0xc0,0x74,0x17,0x3c,
0xff,0x74,9,0xb4,0xe,0xbb,7,0,0xcd,0x10,0xeb,0xee,0xbe,0x81,0x7d,0xeb,
0xe5,0xbe,0x7f,0x7d,0xeb,0xe0,0x98,0xcd,0x16,0x5e,0x1f,0x66,0x8f,4,0xcd,0x19,
0x41,0x56,0x66,0x6a,0,0x52,0x50,6,0x53,0x6a,1,0x6a,0x10,0x8b,0xf4,0x60,
0x80,0x7e,2,0xe,0x75,4,0xb4,0x42,0xeb,0x1d,0x91,0x92,0x33,0xd2,0xf7,0x76,
0x18,0x91,0xf7,0x76,0x18,0x42,0x87,0xca,0xf7,0x76,0x1a,0x8a,0xf2,0x8a,0xe8,0xc0,
0xcc,2,0xa,0xcc,0xb8,1,2,0x8a,0x56,0x40,0xcd,0x13,0x61,0x8d,0x64,0x10,
0x5e,0x72,0xa,0x40,0x75,1,0x42,3,0x5e,0xb,0xe2,0xb5,0xf8,0xc3,3,0x18,
1,0x27,0xd,0xa,0x49,0x6e,0x76,0x61,0x6c,0x69,0x64,0x20,0x73,0x79,0x73,0x74,
0x65,0x6d,0x20,0x64,0x69,0x73,0x6b,0xff,0xd,0xa,0x44,0x69,0x73,0x6b,0x20,0x49,
0x2f,0x4f,0x20,0x65,0x72,0x72,0x6f,0x72,0xff,0xd,0xa,0x52,0x65,0x70,0x6c,0x61,
0x63,0x65,0x20,0x74,0x68,0x65,0x20,0x64,0x69,0x73,0x6b,0x2c,0x20,0x74,0x68,0x65,
0x6e,0x20,0x70,0x72,0x65,0x73,0x73,0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,0xd,
0xa,0,0x52,0x52,0x4c,0,0,0,0x49,0x4f,0x20,0x20,0x20,0x20,0x20,0x20,
0x53,0x59,0x53,0x4d,0x53,0x44,0x4f,0x53,0x20,0x20,0x20,0x53,0x59,0x53,0x7e,0x7d,
0,0x57,0x49,0x4e,0x42,0x4f,0x4f,0x54,0x20,0x53,0x59,0x53,0,0,0x55,0xaa
};

unsigned char p40[]={
0x1F,0x80,0x7E,0x1F,0xFF,0x75,0x19,0x81,0x7E,0x22,0xFF,0,0x72,0x12,0x2B,0x46,
0x1C,0x1B,0x56,0x1E,0x89,0x44,8,0x89,0x54,0xA,0x8B,0x46,0x1D,1,0x44,0xB,
0xB4,0x42
};

#define p40o 0x145
#define p40l sizeof(p40)

unsigned char fat32c[]={
0xfa,0x66,0xf,0xb6,0x46,0x10,0x66,0x8b,0x4e,0x24,0x66,0xf7,0xe1,0x66,3,0x46,
0x1c,0x66,0xf,0xb7,0x56,0xe,0x66,3,0xc2,0x33,0xc9,0x66,0x89,0x46,0xfc,0x66,
0xc7,0x46,0xf8,0xff,0xff,0xff,0xff,0xfa,0x66,0x8b,0x46,0x2c,0x66,0x83,0xf8,2,
0xf,0x82,0xcf,0xfc,0x66,0x3d,0xf8,0xff,0xff,0xf,0xf,0x83,0xc5,0xfc,0x66,0xf,
0xa4,0xc2,0x10,0xfb,0x52,0x50,0xfa,0x66,0xc1,0xe0,0x10,0x66,0xf,0xac,0xd0,0x10,
0x66,0x83,0xe8,2,0xe8,0x2f,1,0x90,0x90,0x89,0xce,0x66,0xf7,0xe1,0x66,3,
0x46,0xfc,0x66,0xf,0xa4,0xc2,0x10,0xfb,0xbb,0,7,0x8b,0xfb,0xb9,1,0,
0xe8,0xbe,0xfc,0xf,0x82,0xaa,0xfc,0x38,0x2d,0x74,0x1e,0xb1,0xb,0x56,0xbe,0xd8,
0x7d,0xf3,0xa6,0x5e,0x74,0x19,3,0xf9,0x83,0xc7,0x15,0x3b,0xfb,0x72,0xe8,0x4e,
0x75,0xd6,0x58,0x5a,0xe8,0x66,0,0x72,0xab,0x83,0xc4,4,0xe9,0x64,0xfc,0x83,
0xc4,4,0x8b,0x75,9,0x8b,0x7d,0xf,0x8b,0xc6,0xfa,0x66,0xc1,0xe0,0x10,0x8b,
0xc7,0x66,0x83,0xf8,2,0x72,0x3b,0x66,0x3d,0xf8,0xff,0xff,0xf,0x73,0x33,0x66,
0x48,0x66,0x48,0xe8,0xc0,0,0x90,0x90,0x66,0xf7,0xe1,0x66,3,0x46,0xfc,0x66,
0xf,0xa4,0xc2,0x10,0xfb,0xbb,0,7,0x53,0xb9,4,0,0xe8,0x52,0xfc,0x5b,
0xf,0x82,0x3d,0xfc,0x81,0x3f,0x4d,0x5a,0x75,8,0x81,0xbf,0,2,0x42,0x4a,
0x74,6,0xbe,0x80,0x7d,0xe9,0xe,0xfc,0xea,0,2,0x70,0,3,0xc0,0x13,
0xd2,3,0xc0,0x13,0xd2,0xe8,0x18,0,0xfa,0x26,0x66,0x8b,1,0x66,0x25,0xff,
0xff,0xff,0xf,0x66,0xf,0xa4,0xc2,0x10,0x66,0x3d,0xf8,0xff,0xff,0xf,0xfb,0xc3,
0xbf,0,0x82,0xfa,0x66,0xc1,0xe0,0x10,0x66,0xf,0xac,0xd0,0x10,0x66,0xf,0xb7,
0x4e,0xb,0x66,0x33,0xd2,0x66,0xf7,0xf1,0x66,0x3b,0x46,0xf8,0x74,0x44,0x66,0x89,
0x46,0xf8,0x66,3,0x46,0x1c,0x66,0xf,0xb7,0x4e,0xe,0x66,3,0xc1,0x66,0xf,
0xb7,0x5e,0x28,0x83,0xe3,0xf,0x74,0x16,0x3a,0x5e,0x10,0xf,0x83,0xa4,0xfb,0x52,
0x66,0x8b,0xc8,0x66,0x8b,0x46,0x24,0x66,0xf7,0xe3,0x66,3,0xc1,0x5a,0x52,0x66,
0xf,0xa4,0xc2,0x10,0xfb,0x8b,0xdf,0xb9,1,0,0xe8,0xb4,0xfb,0x5a,0xf,0x82,
0x9f,0xfb,0xfb,0x8b,0xda,0xc3,0x66,0xf,0xb6,0x4e,0xd,0xfe,0xc9,0x41,0xc3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x55,0xaa
};

unsigned char fat32cb[]={
0xfa,0x66,0xf,0xb6,0x46,0x10,0x66,0x8b,0x4e,0x24,0x66,0xf7,0xe1,0x66,3,0x46,
0x1c,0x66,0xf,0xb7,0x56,0xe,0x66,3,0xc2,0x33,0xc9,0x66,0x89,0x46,0xfc,0x66,
0xc7,0x46,0xf8,0xff,0xff,0xff,0xff,0xfa,0x66,0x8b,0x46,0x2c,0x66,0x83,0xf8,2,
0xf,0x82,0xcf,0xfe,0x66,0x3d,0xf8,0xff,0xff,0xf,0xf,0x83,0xc5,0xfe,0x66,0xf,
0xa4,0xc2,0x10,0xfb,0x52,0x50,0xfa,0x66,0xc1,0xe0,0x10,0x66,0xf,0xac,0xd0,0x10,
0x66,0x83,0xe8,2,0xe8,0x2f,1,0x90,0x90,0x89,0xce,0x66,0xf7,0xe1,0x66,3,
0x46,0xfc,0x66,0xf,0xa4,0xc2,0x10,0xfb,0xbb,0,0x80,0x8b,0xfb,0xb9,1,0,
0xe8,0xbe,0xfe,0xf,0x82,0xaa,0xfe,0x38,0x2d,0x74,0x1e,0xb1,0xb,0x56,0xbe,0xd8,
0x7d,0xf3,0xa6,0x5e,0x74,0x19,3,0xf9,0x83,0xc7,0x15,0x3b,0xfb,0x72,0xe8,0x4e,
0x75,0xd6,0x58,0x5a,0xe8,0xf8,0,0x72,0xab,0x83,0xc4,4,0xe9,0x64,0xfe,0x83,
0xc4,4,0x8b,0x75,9,0x8b,0x7d,0xf,0x8b,0xc6,0xfa,0x66,0xc1,0xe0,0x10,0x8b,
0xc7,0x66,0x83,0xf8,2,0x72,0x3b,0x66,0x3d,0xf8,0xff,0xff,0xf,0x73,0x33,0x66,
0x48,0x66,0x48,0xe8,0xc0,0,0x90,0x90,0x66,0xf7,0xe1,0x66,3,0x46,0xfc,0x66,
0xf,0xa4,0xc2,0x10,0xfb,0xbb,0,7,0x53,0xb9,1,0,0xe8,0xba,0,0x5b,
0xf,0x82,0x3d,0xfe,0x81,0x3f,0x4d,0x5a,0x75,8,0x81,0xbf,0,2,0x42,0x4a,
0x74,6,0xbe,0x80,0x7d,0xe9,0xe,0xfe,0xea,0,2,0x70,0,3,0xc0,0x13,
0xd2,3,0xc0,0x13,0xd2,0xe8,0x18,0,0xfa,0x26,0x66,0x8b,1,0x66,0x25,0xff,
0xff,0xff,0xf,0x66,0xf,0xa4,0xc2,0x10,0x66,0x3d,0xf8,0xff,0xff,0xf,0xfb,0xc3,
0xbf,0,0x7e,0xfa,0x66,0xc1,0xe0,0x10,0x66,0xf,0xac,0xd0,0x10,0x66,0xf,0xb7,
0x4e,0xb,0x66,0x33,0xd2,0x66,0xf7,0xf1,0x66,0x3b,0x46,0xf8,0x74,0x44,0x66,0x89,
0x46,0xf8,0x66,3,0x46,0x1c,0x66,0xf,0xb7,0x4e,0xe,0x66,3,0xc1,0x66,0xf,
0xb7,0x5e,0x28,0x83,0xe3,0xf,0x74,0x16,0x3a,0x5e,0x10,0xf,0x83,0xa4,0xfd,0x52,
0x66,0x8b,0xc8,0x66,0x8b,0x46,0x24,0x66,0xf7,0xe3,0x66,3,0xc1,0x5a,0x52,0x66,
0xf,0xa4,0xc2,0x10,0xfb,0x8b,0xdf,0xb9,1,0,0xe8,0xb4,0xfd,0x5a,0xf,0x82,
0x9f,0xfd,0xfb,0x8b,0xda,0xc3,0x66,0xf,0xb6,0x4e,0xd,0xfe,0xc9,0x41,0xc3,6,
0x68,0,0x10,7,0xe8,0x66,0xff,7,0xc3,6,0xbb,0,0x10,0x8e,0xc3,0x31,
0xdb,0xe8,0x8d,0xfd,0x60,0x1e,6,0x1f,7,0x31,0xf6,0xbf,0,7,0xb9,0,
4,0xf3,0xa5,6,0x1f,0x61,7,0xc3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x55,0xaa
};

unsigned char dos6[]={
0xeb,0x3c,0x90,0x52,0x2e,0x20,0x4c,0x6f,0x65,0x77,0x20,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x29,0,0,0,0,0x4e,0x4f,0x20,0x4e,0x41,
0x4d,0x45,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0 ,0x20,0x20,0x20,0xfa,0x33,
0xc0,0x8e,0xd0,0xbc,0,0x7c,0x16,7,0xbb,0x78,0,0x36,0xc5,0x37,0x1e,0x56,
0x16,0x53,0xbf,0x3e,0x7c,0xb9,0xb,0,0xfc,0xf3,0xa4,6,0x1f,0xc6,0x45,0xfe,
0xf,0x8b,0xe,0x18,0x7c,0x88,0x4d,0xf9,0x89,0x47,2,0xc7,7,0x3e,0x7c,0xfb,
0xcd,0x13,0x72,0x79,0x33,0xc0,0x39,6,0x13,0x7c,0x74,8,0x8b,0xe,0x13,0x7c,
0x89,0xe,0x20,0x7c,0xa0,0x10,0x7c,0xf7,0x26,0x16,0x7c,3,6,0x1c,0x7c,0x13,
0x16,0x1e,0x7c,3,6,0xe,0x7c,0x83,0xd2,0,0xa3,0x50,0x7c,0x89,0x16,0x52,
0x7c,0xa3,0x49,0x7c,0x89,0x16,0x4b,0x7c,0xb8,0x20,0,0xf7,0x26,0x11,0x7c,0x8b,
0x1e,0xb,0x7c,3,0xc3,0x48,0xf7,0xf3,1,6,0x49,0x7c,0x83,0x16,0x4b,0x7c,
0,0xbb,0,5,0x8b,0x16,0x52,0x7c,0xa1,0x50,0x7c,0xe8,0x92,0,0x72,0x1d,
0xb0,1,0xe8,0xac,0,0x72,0x16,0x8b,0xfb,0xb9,0xb,0,0xbe,0xe6,0x7d,0xf3,
0xa6,0x75,0xa,0x8d,0x7f,0x20,0xb9,0xb,0,0xf3,0xa6,0x74,0x18,0xbe,0x9e,0x7d,
0xe8,0x5f,0,0x33,0xc0,0xcd,0x16,0x5e,0x1f,0x8f,4,0x8f,0x44,2,0xcd,0x19,
0x58,0x58,0x58,0xeb,0xe8,0x8b,0x47,0x1a,0x48,0x48,0x8a,0x1e,0xd,0x7c,0x32,0xff,
0xf7,0xe3,3,6,0x49,0x7c,0x13,0x16,0x4b,0x7c,0xbb,0,7,0xb9,3,0,
0x50,0x52,0x51,0xe8,0x3a,0,0x72,0xd8,0xb0,1,0xe8,0x54,0,0x59,0x5a,0x58,
0x72,0xbb,5,1,0,0x83,0xd2,0,3,0x1e,0xb,0x7c,0xe2,0xe2,0x8a,0x2e,
0x15,0x7c,0x8a,0x16,0x24,0x7c,0x8b,0x1e,0x49,0x7c,0xa1,0x4b,0x7c,0xea,0,0,
0x70,0,0xac,0xa,0xc0,0x74,0x29,0xb4,0xe,0xbb,7,0,0xcd,0x10,0xeb,0xf2,
0x3b,0x16,0x18,0x7c,0x73,0x19,0xf7,0x36,0x18,0x7c,0xfe,0xc2,0x88,0x16,0x4f,0x7c,
0x33,0xd2,0xf7,0x36,0x1a,0x7c,0x88,0x16,0x25,0x7c,0xa3,0x4d,0x7c,0xf8,0xc3,0xf9,
0xc3,0xb4,2,0x8b,0x16,0x4d,0x7c,0xb1,6,0xd2,0xe6,0xa,0x36,0x4f,0x7c,0x8b,
0xca,0x86,0xe9,0x8a,0x16,0x24,0x7c,0x8a,0x36,0x25,0x7c,0xcd,0x13,0xc3,0xd,0xa,
0x4e,0x6f,0x6e,0x2d,0x53,0x79,0x73,0x74,0x65,0x6d,0x20,0x64,0x69,0x73,0x6b,0x20,
0x6f,0x72,0x20,0x64,0x69,0x73,0x6b,0x20,0x65,0x72,0x72,0x6f,0x72,0xd,0xa,0x52,
0x65,0x70,0x6c,0x61,0x63,0x65,0x20,0x61,0x6e,0x64,0x20,0x70,0x72,0x65,0x73,0x73,
0x20,0x61,0x6e,0x79,0x20,0x6b,0x65,0x79,0x20,0x77,0x68,0x65,0x6e,0x20,0x72,0x65,
0x61,0x64,0x79,0xd,0xa,0,0x49,0x4f,0x20,0x20,0x20,0x20,0x20,0x20,0x53,0x59,
0x53,0x4d,0x53,0x44,0x4f,0x53,0x20,0x20,0x20,0x53,0x59,0x53,0,0,0x55,0xaa,
};

int post(b,s,l)
char *b;
long s;
int l;
{
if (d>=0) {
rtp: if (blk13(0x43,d,start+s,b,l)) if (blk13(0x43,d,start+s,b,l)) {
if (lk==0) {
if (int440d(0x81,d)) goto nophy;
lk=1;goto rtp;
}
if (int440d(0x80,d)) printf("Physical UnLock Error\n");
lk=0;
nophy: d= -1;
if (ld>0) printf("\nCannot Write Physical Drive - Switching to Logical Drive\n");
goto log;
}
return(0);
}
log: if (ld>0) {
if (lk==0) {
if (int440d(1,ld)) if (int440d(1,ld+256)) {printf("Logical Lock Error\n");goto bad;}
lk=1;
}
if (int2173(3,ld,s,l,b)) if (int2173(3,ld,s,l,b)) {
int440d(0,ld);lk=0;goto bad;
}
return(0);
}
bad: printf("Error Writing Disk\n");return(20);
}

void clear(b,l)
char *b;
unsigned int l;
{
unsigned int i;
for (i=0;i<l;i+=4) *(long *)(b+i)=0;
}

#endif

blk13x(c,d,x,y,buff,n)
int c,d,n;
long x,y,*buff;
{
long arg[8];
int a,b,s;
arg[0]=n;arg[0]=(arg[0]<<16)+0x10;
s=(int)arg;a=c<<8;
switch(c) {
case 0x42: 
case 0x43: arg[1]=(int)buff;arg[2]=x;arg[3]=y;break;
default: return(1);
};
asm {
push dx
push si
mov dx,[d]
mov si,[s]
mov ax,ds
mov [si+6],ax
mov ax,[a]
int 0x13
pop si
pop dx
jc err
mov [a],0
}
err: return(a);
}

blk13(c,d,x,buff,n)
int c,d,n;
unsigned long x,*buff;
{
int r;
unsigned long y,z;
if (l40==0) return(blk13x(c,d,x,0L,buff,n));
y=x-start;z=y+((start<<16)&0xff000000);
y=(z<y) ? 1 : 0;y+=(start>>16)&255; 
if (x-start) return(blk13x(c,d,z,y,buff,n));
if (c==0x42) return(blk13x(c,d,x,0L,buff,n));
if (r=blk13x(c,d,x,0L,buff,n)) return(r);
return(blk13x(c,d,z,y,buff,n));
}

void cfg(d,b)
int d,b;
{
_asm {
push bx
push cx
push dx
push ds
push ss
pop ds
mov ax,0x440d
mov bx,[d]
mov cx,0x4840
mov dx,[b]
int 0x21
mov ax,0x440d
mov cx,0x0840
int 0x21
pop ds
pop dx
pop cx
pop bx
};
}

main(c,v)
int c;
char **v;
{
unsigned long secs,base,root,num,cnum,bsecs,bbase,broot,bk,bcnum,fc,fp,psz;
unsigned int align,off,dir,boff,bdir,cs,csize,bcsize,ssize,bssize;
unsigned char fats,media,type,h,s,drv,bfats,bmedia,btype,bh,bs,bo,bdrv;
unsigned char buff[32780L],ext[4],dp[96];
int i,d6,lg,ldr,fix;
unsigned long j,k,l;
char *nw,tbw;
fix=0;tbw=0;
redo: secs=base=root=broot=num=0;align=off=dir=0;type=0;ext[0]=0;
cs=csize=ssize=fats=media=h=s=bo=lg=lk=ldr=0;d6=0;drv=0xff;
arg: if (c>2) if (v[1][0]=='-') {
if ((v[1][1]&0xdf)=='B') {bo++;c--;v++;goto arg;}
if ((v[1][1]&0xdf)=='D') {d6=1;c--;v++;goto arg;}
if ((v[1][1]&0xdf)=='L') {lg=1;c--;v++;goto arg;}
if ((v[1][1]&0xdf)=='E') {
if (strlen(v[2])-3) {printf("Extension Must Be 3 Characters\n");return(20);}
strcpy(ext,v[2]);c-=2;v+=2;
for (i=0;i<3;i++) if ((ext[i]>='a') && (ext[i]<='z')) ext[i]-=32;
goto arg;
}
}
if (c<3) {printf("RFORMAT [-BootOnly....] [-DOS6] [-Ext EXT] [-LogOnly]\n   DrvLtr|(Num Off|Pri#|Log#) 12|16|32|Erase\n   [Secs #] [ClusSize #] [Offset #] [FATSize #] [RootClus #] [DirEnts #]\n   [Align #] [Media #] [Geometry H# S# Slen#] [Base #] [NumFats #] [Unit #]\n");return(20);}
printf("\nR. Loew Electronics Drive Formatting Utility  Version 1.4\nCopyright (C) 2010, All Rights Reserved\n\n");

#ifdef DEMO
printf("DEMO Version - Writing Disabled\n\n");
#endif

ld=v[1][0];
if ((ld>='0') && (ld<='9')) {
if (lg) {printf("Not Logical Drive\n");return(20);}
d=getnum(v[1]);
if (v[2][0]>'9') {
if (blk13(0x42,d,0L,buff,1)) if (blk13(0x42,d,0L,buff,1)) {
printf("Error Reading MBR\n");return(20);
}
}
if ((v[2][0]&0xdf)=='P') {
v[2][1]=v[2][strlen(v[2])-1];
if ((v[2][1]<'1') || (v[2][1]>'4')) {
invp: printf("Invalid Partition #\n");return(20);
}
j=(v[2][1]-'1')<<4;ld=buff[0x1c2+j];
if (ld==0) {printf("Partition Slot Empty\n");return(20);}
if ((ld==5) || (ld==15)) {printf("Cannot Format Extended Partition\n");return(20);}
start= *(long *)(buff+0x1c6+j);secs= *(long *)(buff+0x1ca+j);goto gotprt;
}
if ((v[2][0]&0xdf)=='L') {
while(v[2][0]>'9') v[2]++;
for (j=0x1c2;j<0x202;j+=16) if ((buff[j]==5) || (buff[j]==15)) goto fndext;
printf("No Extended or Logical Partitions\n");return(20);
fndext: start= *(long *)(buff+j+4);
j=getnum(v[2]);k=0;
if (j<1) goto invp;
extlp: if (blk13(0x42,d,start+k,buff,1)) if (blk13(0x42,d,start+k,buff,1)) {
printf("Error Reading Extended Record\n");return(20);
}
if (--j) {
for (k=0x1c2;k<0x202;k+=16) if ((buff[k]==5) || (buff[k]==15)) goto fndext1;
goto invp;
fndext1: k= *(long *)(buff+k+4);goto extlp;
}
for (j=0x1c2;j<0x202;j+=16) if (buff[j] && (buff[j]-5) && (buff[j]-15)) goto fndlog;
goto invp;                                              
fndlog: start+=k+ *(long *)(buff+j+4);secs= *(long *)(buff+j+8); 
goto gotprt;
}
start=getnum(v[2]);
gotprt: if (secs) printf("Partition:  Drive 0x%x:  Start=%lu  Length=%lu\n\n",d,start,secs);j=0;ld= -1;c--;v++;
}
else {
if ((ld&0xe0)==0x60) ld-=32;
ld-=64;ldr=ld;
if ((ld<1) || (ld>26)) {printf("Bad Drive Letter\n");return(20);}
}
type=getnum(v[2]);
if ((v[2][0]&0xdf)=='E') goto clr1;
if ((type-12) && (type-16) && (type-32)) {printf("Invalid FAT Type\n");return(20);}
if (d6 && (type==32)) {printf("FAT32 Not Supported by DOS 6\n");return(20);}
for (i=3;i<c;i+=2) {
if (c<(i+2)) goto badarg;
j=getnum(v[i+1]);
switch(v[i][0]&0xdf) {
case 'A': align=j;
          if (j&(j-1)) {printf("Alignment Must be Power of 2\n");return(20);}
          break;
case 'B': base=j;break;
case 'S': secs=j;break;
case 'F': if (j>=0x200000) goto badarg;
          num=j;break;
case 'R': if (j>=0xffffff0) goto badarg;
          root=j;break;
case 'O': if (j>65535) goto badarg;
          off=j;break;
case 'D': dir=j;break;
case 'C': if (j<1) goto badarg;
          if (j>256) if (j&(j-1)) goto badarg;
          cs=csize=j;break;
case 'N': if ((j<1) || (j>4)) goto badarg;
          fats=j;break;
case 'M': if (j>255) goto badarg;
          media=j;break;
case 'U': if (j>255) goto badarg;
          drv=j;break;
case 'G': if (j>255) goto badarg;
          h=j;j=getnum(v[i+2]);i++;
          if (j>255) goto badarg;
          s=j;j=getnum(v[i+2]);i++;
          if (j&(j-1)) goto badarg;
          if (j<512) goto badarg;
          ssize=j;break;
default:  badarg: printf("Bad Argument: %s %s\n",v[i],v[i+1]);return(20);
};
}
clr1: if (ld>0) {
d=drive(ld,&start,&j);
if (d<0) {
i=int440d(8,ld,&d,&start,&j);
if (d==0xff) d= -1;
if (i) {
if (fix==0) printf("WARNING - No Geometry Information\n");
start=j=0;
}
}
}
if (d>=0) {
_asm {
pusha
mov ax,0x800
mov dx,[d]
int 0x13
jc  noint
and cx,0x3f
mov [s8],cx
mov dl,dh
mov dh,0
inc dx
mov [h8],dx
};
noint: _asm {
popa
};
}
if (ld>0) {
if (lg) d= -1;
else {
if (fix==0) {
if (d<0) printf("\nNo Physical Drive  Offset 0x%lx\n\n",start);
else {
if (start>0xff000000) printf("\nPhysical Drive 0x%x  Offset 0x%lx (%ld:%ld)\n\n",d,start,(start>>16)&255,(start>>8)&255);
else printf("\nPhysical Drive 0x%x  Offset 0x%lx\n\n",d,start);
}
}
}
}
if (align) if (start==0) {printf("Cannot Align Data Area Without Partition Offset\n");return(20);}
k=7;l=11;
for (secsize=0;secsize<32768L;secsize++) {
k+=k<<4;l+=(l<<3)+(l<<2);buff[secsize]=(k^l)>>4;
}
getr: if (ld>0) {
if (int2173(2,ld,0L,1,buff)) {
if (int2173(2,ld,0L,1,buff)) {
if (int2173(2,ld,6L,1,buff)) {ld= -1;goto getr;}
}
}
}
else {
if (blk13(0x42,d,start,buff,1)) {
if (blk13(0x42,d,start,buff,1)) {
if (blk13(0x42,d,start+6,buff,1)) {
printf("Error Reading Boot Block\n");return(20);
}
}
}
}
k=7;l=11;secsize=0;
for (bk=0;bk<32768L;bk++) {
k+=k<<4;l+=(l<<3)+(l<<2);buff[0]=(k^l)>>4;
if (buff[bk]-buff[0]) secsize=bk;
}
while(bk=secsize&(secsize-1)) secsize=bk;
secsize<<=1;
if (secsize<512) secsize=512;
if (ssize==0) ssize=secsize;
switch(ssize) {
case 512: secshft=9;dircnt=224;break;
case 1024: secshft=10;dircnt=224;break;
case 2048: secshft=11;dircnt=256;break;
case 4096: secshft=12;dircnt=256;break;
case 8192: secshft=13;dircnt=256;break;
case 16384: secshft=14;dircnt=512;break;
case 32768L: secshft=15;dircnt=1024;break;
};
maxsec=32768L>>secshft;dirsec=ssize>>5;
if (dir) {
dir=(dir+(dirsec-1))&(-dirsec);
if (dir<dirsec) {printf("Specified Root Directory Too Big\n");return(20);}
}
if (fix==0) printf("Device Logical Sector Size %u\n",secsize);
if (type==0) goto clr2;
if (secs==0) secs=j;
if (secs==0) {printf("\nNumber of Sectors Must Be Specified\n");return(20);}
if (base==0) base=start;
if (root==0) if (type==32) root=2;
if (off==0) off=(type==32) ? 32 : 1;
off+=fix;
if (dir==0) {
if (type-32) dir=((d<2) && (ld<3)) ? dircnt : ((dircnt>512) ? 1024 : 512);
}
if (fats==0) fats=2;
if (media==0) media=((d<2) && (ld<3)) ? 0xf0 : 0xf8;
if (drv==0xff) drv=((d<2) && (ld<3)) ? 0 : 0x80;
if ((d<2) && (ld<3)) if (h8==255) {s8=2;h8=18;}
if (s==0) s=s8;
if (h==0) h=h8;
if (type==32) if (off<2) {printf("\nReserved Area must be at least 2 Sectors in FAT32\n");return(20);}
if (type-32) if (root) {printf("\nRoot can only be set in FAT32\n");return(20);}
if (type==32) if (dir) {printf("\nDirectory Entries cannot be set in FAT32\n");return(20);}
psz=j;
if (csize==0) {
if (type==32) {
j=csize=4096>>secshft;
while (csize && (((fats<<(18-secshft))+(j*65528L)+off)>secs)) j=csize=csize>>1;
}
if (csize==0) csize=1;
}
if (type==12) if (secs>0x100000) goto big;
if (type==16) if (secs>0x10000000) goto big;
j=secs-off;
if (type-32) j-=dir>>(secshft-5);
if (j>secs) {printf("\nInvalid Drive Size\n");return(20);}
goto clp0;
clp: if ((csize-1)&0xff00) {
big: printf("\nDrive or Cluster Size Too Large for Specified Settings\n");
return(20);
}
clp0: if (num) {bk=k=num;goto clp2;}
l=csize;l=((l<<(secshft+3))+32)/type;bk=(j+l-1)/l;  // From IO.SYS 7.0
k=0;
clp1: l=k;cnum=((j-(k*fats))/csize)+2;
if (cnum>0x11000000) goto cnext;
k=cnum*(type>>2);k=(k+ssize+ssize-1)>>(secshft+1);

// printf("j=%lu,k=%ld,cnum=%ld,l=%ld,csize=%u,fix=%u\n",j,k,cnum,l,csize,fix);

if ((k-l) && (k-l+1)) goto clp1;
clp2: cnum=((j-(k*fats))/csize)+2;
l=(k<<(secshft+1))/(type>>2);
if (num==0) {
if (l<(cnum-fats)) printf("\nProgram Error:  Clusters = %ld  Max Clusters = %ld\n",cnum,l); 
if (l<cnum) cnum=l;
}
if ((type==12) && (cnum>0xff6)) goto cnext;
if ((type==16) && (cnum>0xfff6)) goto cnext;
if ((type==32) && (cnum>0xffffff0)) goto cnext;
if (cs || (csize>(32767>>secshft)) || (cnum<0x200000)) goto cok;
cnext: csize<<=1;goto clp;
cok: if (l<cnum) cnum=l;
if ((type==16) && (cnum<0xff8)) {
printf("Not Enough Clusters for FAT16\n");return(20);
}
if ((root>=cnum) || (root==1)) {printf("\nInvalid Root Cluster\n");return(20);}
if (align) {
l=0;
if (type-32) l=(dir+dirsec-1)>>(secshft-5);
if (((secs+start)<start) && (start>=0xff000000) && (type==32)) l+=off+k*fats;
else l+=start+off+k*fats;
l&=align-1;
if (l) {l=align-l;fix=l%fats;off+=fix;k+=l/fats;goto clp2;}
}
if (((off+k*fats)&((4096>>secshft)-1))==0) if (secs>0x80000000) {
if (align==0) {
printf("\nWARNING - Format Requires 1TB VFAT Patch - Incr. Offset Workaround (Y/N) ? (N) ");
read(0,&i,2);
if ((i&0xdf)=='Y') {fix++;goto redo;}
}
else tbw=1;
printf("\nWARNING - Format Requires 1TB VFAT Patch\n");
}
if (bk-k) printf("\nDOS FAT Sectors = %ld\n",bk);
clr2: if ((*(unsigned int *)(buff+510))-0xaa55) goto noboot;
j= *(unsigned int *)(buff+0x13);
if (j) bsecs=j;
else bsecs= *(long *)(buff+0x20);
bk= *(unsigned int *)(buff+0x16);
if (bk) {
if ((*(long *)(buff+0x36))-0x31544146) goto noboot;
bdrv=buff[0x24];
if (buff[0x3a]==0x32) {btype=12;goto bok;}
if (buff[0x3a]==0x36) {btype=16;goto bok;}
goto noboot;
}
if (((*(long *)(buff+0x52))-0x33544146) || (buff[0x56]-0x32)) goto noboot;
btype=32;bk= *(long *)(buff+0x24);broot= *(long *)(buff+0x2c);
bdrv=buff[0x40];
bok: bcsize=buff[0xd];
if (bcsize==0) bcsize=256;
if (bcsize&0x80) if (bcsize&0x7f) bcsize=(bcsize<<9)&0xff00;
bssize= *(unsigned int *)(buff+0xb);
bbase= *(long *)(buff+0x1c);boff= *(int *)(buff+0xe);
bdir= *(int *)(buff+0x11);bfats=buff[0x10];bmedia=buff[0x15];j=bsecs-boff;
if (btype-32) j-=(bdir+dirsec-1)>>(secshft-5);
bcnum=((j-(bk*bfats))/bcsize)+2;

//adj: j=bcnum*(btype>>2);j=(j+ssize+ssize-1)>>(secshft+1);
//if (j>bk) {bcnum+=bk-j;goto adj;}

j=(bk<<(secshft+3))/btype;

//printf("new j=%ld\n",j);

if (j<bcnum) bcnum=j;
bh=buff[0x1a];bs=buff[0x18];
if (type==0) {
printf("\nExisting File System Found\n");
printf("\nFileSys Type:     Old =      FAT%2d\n",btype);
printf("Total Sectors:    Old = %10lu\n",bsecs);
printf("Cluster Size:     Old = %10u\n",bcsize);
printf("Clusters:         Old = %10ld\n",bcnum);
printf("Start Sector:     Old = %10lu\n",bbase);
printf("Root Cluster:     Old = %10ld\n",broot);
printf("Offset Sectors:   Old = %10d\n",boff);
printf("Directory Ents:   Old = %10d\n",bdir);
printf("Number of FATs:   Old = %10d\n",bfats);
printf("Media Byte:       Old =         %02X\n",bmedia);
printf("Boot Drive:       Old =       0x%02X\n",bdrv);
printf("Sectors Per FAT:  Old = %10ld\n",bk);
printf("Sector Length:    Old = %10u\n",bssize);
printf("Sectors Per Trk:  Old = %10d\n",bs);
printf("Heads Per Cyl:    Old = %10d\n",bh);
mt=1;goto ok;
}
if (type-btype) goto diff;
if (secs-bsecs) goto diff;
if (csize-bcsize) goto diff;
if (cnum-bcnum) goto diff;
if (base-bbase) goto diff;
if (root-broot) goto diff;
if (off-boff) goto diff;
if (dir-bdir) goto diff;
if (fats-bfats) goto diff;
if (media-bmedia) goto diff;
if (drv-bdrv) goto diff;
if (k-bk) goto diff;
if (ssize-bssize) goto diff;
if (s-bs) goto diff;
if (h-bh) goto diff;
printf("\nExisting File System Found With Same Format\n");mt=4;nw="";goto same;
diff: printf("\nExisting File System Found With Different Format\n");
printf("\nFileSys Type:     New =      FAT%2d  Old =      FAT%2d\n",type,btype);
printf("Total Sectors:    New = %10lu  Old = %10lu\n",secs,bsecs);
printf("Cluster Size:     New = %10u  Old = %10u\n",csize,bcsize);
printf("Clusters:         New = %10ld  Old = %10ld\n",cnum,bcnum);
printf("Start Sector:     New = %10lu  Old = %10lu\n",base,bbase);
printf("Root Cluster:     New = %10ld  Old = %10ld\n",root,broot);
printf("Offset Sectors:   New = %10d  Old = %10d\n",off,boff);
printf("Directory Ents:   New = %10d  Old = %10d\n",dir,bdir);
printf("Number of FATs:   New = %10d  Old = %10d\n",fats,bfats);
printf("Media Byte:       New =         %02x  Old =         %02x\n",media,bmedia);
printf("Boot Drive:       New =       0x%02x  Old =       0x%02x\n",drv,bdrv);
printf("Sectors Per FAT:  New = %10ld  Old = %10ld\n",k,bk);
printf("Sector Length:    New = %10u  Old = %10u\n",ssize,bssize);
printf("Sectors Per Trk:  New = %10d  Old = %10d\n",s,bs);
printf("Heads Per Cyl:    New = %10d  Old = %10d\n",h,bh);
mt=3;goto ok;
noboot: printf("\nNo Existing File System Found or File System is Corrupt\n");
mt=2;nw="New =";
if (type==0) goto ok;
same: 
printf("\nFileSys Type:     %s      FAT%2d\n",nw,type);
printf("Total Sectors:    %s %10lu\n",nw,secs);
printf("Cluster Size:     %s %10d\n",nw,csize);
printf("Clusters:         %s %10ld\n",nw,cnum);
printf("Start Sector:     %s %10lu\n",nw,base);
printf("Root Cluster:     %s %10ld\n",nw,root);
printf("Offset Sectors:   %s %10d\n",nw,off);
printf("Directory Ents:   %s %10d\n",nw,dir);
printf("Number of FATs:   %s %10d\n",nw,fats);
printf("Media Byte:       %s         %02X\n",nw,media);
printf("Boot Drive:       %s       0x%02X\n",nw,drv);
printf("Sectors Per FAT:  %s %10ld\n",nw,k);
printf("Sector Length:    %s %10u\n",nw,ssize);
printf("Sectors Per Trk:  %s %10d\n",nw,s);
printf("Heads Per Cyl:    %s %10d\n",nw,h);
ok: printf("\n");
if (type) {
if (type==32) if (off<9) printf("WARNING - Reserved Area should be at least 9 Sectors in FAT32\n");
if (ld>0) if (secs>psz) printf("WARNING - Size greater than Reported Size\n");
if (tbw) printf("\nWARNING - Format Requires 1TB VFAT Patch\n");
if ((type==32) && (cnum<0xfff7)) printf("WARNING - Not Enough Clusters for FAT32\n");
if (csize==256) printf("WARNING - Cluster Size valid only with TBPLUS Patched DOS and Windows\n");
if (csize>256) printf("WARNING - Cluster Size valid only for Patched Windows XP (FASTFAT 2^N MOD)\n");
if (ssize>4096) printf("WARNING - Sector Size valid only with TBPLUS Patched DOS not with Windows\n");
else if (ssize>512) printf("WARNING - Sector Size valid only with TBPLUS Patched DOS and Windows\n");
if ((secs+start)<start) {
if ((start>=0xff000000) && (type==32)) {
printf("WARNING - Partition Start valid only with TBPLUS Patched DOS and Windows\n");l40=1;
}
else printf("WARNING - Partition wraps around to Sector 0\n");
}
else {
if (start>=0xff000000) {
if (psz>=0x1000000) printf("WARNING - Not Enough Sectors for Extended MBR Partition - Will Corrupt Others\n");
else printf("CAUTION - Partition will corrupt Extended MBR Partitions if present\n");
}
}
printf("\n");

#ifndef DEMO
if ((bo==1) || (bo==2)) {
switch(mt) {
case 2: printf ("INSTALL BOOT SECTOR(S) ? (Y/N) (N) ");break;
case 3: printf ("CHANGE BOOT PARAMETERS ? (Y/N) (N) ");break;
case 4: printf ("INITIALIZE BOOT ? (Y/N) (N) ");break;
default: printf("Program Error\n");return(20);
};
}
else printf ("FORMAT DRIVE ? (Y/N) (N) ");
#endif

}

#ifndef DEMO
else printf ("ERASE DRIVE ? (Y/N) (N) ");
read(0,&i,2);
if ((i&0xdf)-'Y') return(5);
clear(buff,32780L);
l=bo ? 1 : 9;
if (mt==1) if (btype-32) l=1;
if (type==0) {
for (k=0;k<l;k++) if (post(buff,k,1)) return(20);
goto done;
}
if (d6) memcpy(buff,dos6,512);
else memcpy(buff,(secsize>4096) ? fat16b : fat16,512);
if (type==12) buff[0x3a]='2';
if (type==16) buff[0x3a]='6';
if (type==32) {
memcpy(buff,fat32,512);
if (secsize>4096) {buff[0xd0]=0x7e;buff[0x102]=0;}
if (l40) memcpy(buff+p40o,p40,p40l);
}
if ((d>0x7f) || (ld>2)) {
if (type==32) buff[0x40]=0x80;
else buff[0x24]=0x80;
}
if (ext[0]) {
if (d6) {memcpy(buff+0x1ee,ext,3);memcpy(buff+0x1f9,ext,3);}
else {memcpy(buff+0x1e0,ext,3);memcpy(buff+0x1eb,ext,3);}
if (type==32) memcpy(buff+0x1f9,ext,3);
}
*(int *)(buff+0xb)=ssize;
buff[0xd]=csize;
if (csize>256) buff[0xd]=(csize>>9)|0x80;
*(int *)(buff+0xe)=off;
buff[0x10]=fats;
*(int *)(buff+0x11)=dir;
if (secs<65536) *(int *)(buff+0x13)=secs;
else *(long *)(buff+0x20)=secs;
buff[0x15]=media;
if (type-32) *(int *)(buff+0x16)=k;
else *(long *)(buff+0x24)=k;
*(int *)(buff+0x18)=s;
*(int *)(buff+0x1a)=h;
*(long *)(buff+0x1c)=base;
if (type==32) *(long *)(buff+0x2c)=root;
if (type-32) {buff[0x24]=drv;time(buff+0x27);}
else {buff[0x40]=drv;time(buff+0x43);}
printf("\nWriting Boot Sector(s)\n");
if (post(buff,0L,1)) return(20);
dp[0]=dp[2]=1;dp[1]=5;dp[3]=dp[6]=0;memcpy(dp+7,buff+11,41);
*(int *)(dp+4)=secs/h/s;clear(dp+48,48);
if (ldr>0) cfg(ldr,dp);
if (type==32) {
if (off>6) if (post(buff,6L,1)) return(20);
clear(buff,512);
*(long *)buff=0x41615252;
*(long *)(buff+0x1e4)=0x61417272;
*(long *)(buff+0x1e8)=cnum-3;
*(long *)(buff+0x1ec)=2;
*(int *)(buff+0x1fe)=0xaa55;
// memcpy(buff+512,(secsize>4096) ? fat32cb : fat32c,512);
if (post(buff,1L,1)) return(20);
*(long *)(buff+0x1e8)= -1;
if (off>7) if (post(buff,7L,1)) return(20);
memcpy(buff,(secsize>4096) ? fat32cb : fat32c,512);
// clear(buff+512,512);
if (off>2) if (post(buff,2L,1)) return(20);
if (off>8) if (post(buff,8L,1)) return(20);
clear(buff,512);
if (off>3) if (post(buff,3L,1)) return(20);
if (off>4) if (post(buff,4L,1)) return(20);
if (off>5) if (post(buff,5L,1)) return(20);
clear(buff,512);
if ((bo&1)==0) for (j=9;j<off;j+=maxsec) {
i=off-j;
if (i>maxsec) i=maxsec;
if (post(buff,j,i)) return(20);
}
}
if ((bo==1) || (bo==2)) goto done;
clear(buff,512);
if (type==12) *(int *)(buff+1)= -1;
if (type==16) *(long *)buff= -1;
if (type==32) {
*(long *)buff= *(long *)(buff+4)=0xfffffff;
if (root==2) *(long *)(buff+8)=0xfffffff;
}
buff[0]=media;
for (fc=0,fp=off;fc<fats;fc++,fp+=k) {
printf("Writing Fat %d\n",fc+1);
for (j=0;j<k;j+=maxsec) {
l=k-j;
if (l>maxsec) l=maxsec;
i=l;
if (post(buff+(j ? 12 : 0),j+fp,i)) return(20);
}
}
if (type==32) if (root-2) {
j=root>>(secshft-2);l=(root&((ssize>>2)-1))<<2;
if (j) *(long *)buff= *(long *)(buff+4)=0;
*(long *)(buff+l)=0xfffffff;
for (fc=0,fp=off;fc<fats;fc++,fp+=k) if (post(buff,j+fp,1)) return(20);
*(long *)(buff+l)=0;
}
clear(buff,12);
printf("Writing Root Directory\n");
if (type-32) {
l=(dir+dirsec-1)>>(secshft-5);fp=off+(k*fats);
for (j=0;j<l;j+=maxsec) {
i=l-j;
if (i>maxsec) i=maxsec;
if (post(buff,j+fp,i)) return(20);
}
}
else {
l=csize;l=off+(k*fats)+((root-2)*l);
for (j=0;j<csize;j+=maxsec) {
i=csize-j;
if ((csize-j)>maxsec) i=maxsec;
if (post(buff,j+l,i)) return(20);
}
}
done: if (lk) {
if (d>=0) int440d(0x80,d);
else int440d(0,ld);
}
if (ldr>0) {
_asm {
push cx
push dx
mov ax,0x710d
mov cx,1
mov dx,[ldr]
int 0x21
pop dx
pop cx
}
}

#endif
return(0);
}
